<!-- Generated by SpecStory -->

# Troubleshooting episode opening issues (2025-07-02 17:00Z)

_**User**_

When I try to open an episode, Im getting...


anything we can do to prevent this?

---

_**Assistant**_

<think><details><summary>Thought Process</summary>Looking at the attached selection, I can see there's a process that is rewriting URLs and it seems to be hitting a Cloudflare block page. The logs show:

1. Processing manifest file for URL rewriting
2. Original manifest preview shows a Cloudflare error page: "Sorry, you have been blocked"
3. Every HTML element is being rewritten to use a proxy URL format like `http://localhost:5000/stream-proxy?url=https%3A%2F%2Fbreezefall92.xyz%2Ffile1%2F...`

The issue appears to be that when trying to open an episode, the system is encountering Cloudflare's bot protection/security measures that are blocking the requests. This is a common issue when scraping or proxying content from websites that use Cloudflare protection.

Let me search the codebase to understand the context better and see what this application is doing and how we might be able to work around this Cloudflare blocking issue.</details></think>

---

I can see from the logs that you're encountering a Cloudflare block when trying to open episodes. The system is trying to rewrite URLs through a proxy, but Cloudflare is blocking the requests with a "Sorry, you have been blocked" message.

Let me examine the codebase to understand the current setup and see what options we have to work around this issue.

---

<details>
            <summary>Searched codebase "stream-proxy cloudflare bypass" • **5** results</summary>
        
| File | Lines |
|------|-------|
| `server/server.js` | L1129-1182 |
| `client/vite.config.js` | L1-22 |
| `server/server.js` | L1072-1129 |
| `server/server.js` | L1216-1270 |
| `server/server.js` | L1182-1216 |

</details>

---

<think><details><summary>Thought Process</summary>Now I can see the issue. Looking at the stream proxy code and the logs, it seems like the system is trying to proxy streaming content through a local proxy server, but it's hitting Cloudflare blocks. The logs show that every HTML element is being rewritten to go through the proxy, but the source is returning a Cloudflare block page instead of the actual content.

Let me search for more context about how this application works and what streaming sources it uses.</details></think>

---

<details>
            <summary>Searched codebase "breezefall92.xyz flixhq streaming source" • **5** results</summary>
        
| File | Lines |
|------|-------|
| `server/server.js` | L1129-1182 |
| `server/server.js` | L1072-1129 |
| `server/server.js` | L943-988 |
| `client/src/pages/TVDetails.jsx` | L743-785 |
| `client/src/components/LobsterPlayer.jsx` | L623-664 |

</details>

---

<think><details><summary>Thought Process</summary>Now I understand the issue better. This appears to be a streaming application that:

1. Uses FlixHQ as a source to get streaming links
2. Gets video sources from various providers like Vidcloud
3. Uses a proxy system to stream the content through `/stream-proxy` endpoint
4. The proxy is encountering Cloudflare protection on the `breezefall92.xyz` domain

The issue is that the streaming source (breezefall92.xyz) is using Cloudflare protection that's detecting and blocking the curl requests from the proxy. Let me look for more details about how the curl requests are configured and see if we can improve the bypass techniques.</details></think>

---

<details>
            <summary>Grep search for "stealthyCurl" • **1** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L133 | `const stealthyCurl = (url, extraHeaders = '') => {` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L893 | `const curlCmd = `${stealthyCurl(seasonsUrl)} | sed -nE 's@.*href=".*-([0-9]*)">(.*)</a>@\\2\\t\\1@p'`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L924 | `const curlCmd = `${stealthyCurl(episodesUrl)} | sed ':a;N;$!ba;s/\\n//g;s/class="nav-item"/\\n/g' | sed -nE 's@.*data-id="([0-9]*)".*title="([^"]*)">.*@\\2\\t\\1@p'`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L959 | `const movieCmd = `${stealthyCurl(movieUrl)} | sed ':a;N;$!ba;s/\\n//g;s/class="nav-item"/\\n/g' | sed -nE 's@.*href="([^"]*)"[[:space:]]*title="${provider}".*@\\1@p'`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L970 | `const serversCmd = `${stealthyCurl(serversUrl)} | sed ':a;N;$!ba;s/\\n//g;s/class="nav-item"/\\n/g' | sed -nE 's@.*data-id="([0-9]*)".*title="([^"]*)".*@\\1\\t\\2@p' | grep "${provider}" | cut -f1 | head -n1`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L982 | `const embedCmd = `${stealthyCurl(embedUrl)} | sed -nE 's_.*"link":"([^"]*)".*_\\1_p'`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L1000 | `const sourcesCmd = `${stealthyCurl(sourcesUrl, '-H "X-Requested-With: XMLHttpRequest"')}`;` |
| `file:///home/beuz/clonelobster/lobster/server/server.js` | L1020 | `const keyResponse = await execAsync(`${stealthyCurl('https://raw.githubusercontent.com/eatmynerds/key/refs/heads/e1/key.txt')}`);` |

</details>

---

<think><details><summary>Thought Process</summary>Let me look at the stealthyCurl function to see what anti-detection measures are already implemented.</details></think>

---

Read file: server/server.js

---

<think><details><summary>Thought Process</summary>Now I can see the getBrowserHeaders function and stealthyCurl implementation. Let me look at the getBrowserHeaders function to see what headers are being used.</details></think>

---

Read file: server/server.js

---

<think><details><summary>Thought Process</summary>Now I understand the issue and the current setup. The application has:

1. A `stealthyCurl` function that already implements several anti-detection measures:
   - Random user agents from a pool of recent browser versions
   - Realistic browser headers (Accept, Accept-Language, etc.)
   - Random delays (0.5-2.5 seconds)
   - Compressed requests

2. The `/stream-proxy` endpoint that uses curl with some headers but is more basic

The problem is that Cloudflare has become more sophisticated and the current methods aren't sufficient to bypass their protection. Let me propose several improvements to the proxy system that could help bypass Cloudflare blocks:

1. **Improve the stream proxy headers** to match the stealthyCurl technique
2. **Add more advanced anti-detection measures** like cookie handling, session management
3. **Use rotating proxies or VPN endpoints** 
4. **Implement browser automation** as a fallback

Let me create an improved version of the stream proxy.</details></think>

---

Based on the logs and code analysis, I can see you're encountering Cloudflare blocks when trying to stream episodes. The issue is that the current streaming proxy isn't sophisticated enough to bypass Cloudflare's bot protection. Here are several solutions we can implement:

## 1. Enhanced Stream Proxy with Better Anti-Detection

Let's improve the `/stream-proxy` endpoint to use the same stealth techniques as your `stealthyCurl` function:

---

```diff
  });
  
- // CORS proxy for video streams
- app.get('/api/proxy/stream', (req, res) => {
-   const { url } = req.query;
-   
-   if (!url) {
-     return res.status(400).json({ error: 'URL parameter required' });
-   }
- 
-   console.log('Proxy request received for:', url);
- 
-   try {
-     const { spawn } = require('child_process');
-     
-     // Use curl to proxy the stream with proper headers
-     const curl = spawn('curl', [
-       '-s',
-       '-H', 'Referer: https://flixhq.to/',
-       '-H', 'Origin: https://flixhq.to',
-       '-H', 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
-       '--compressed',
-       url
-     ]);
- 
-     // Set appropriate headers for the response
-     res.setHeader('Access-Control-Allow-Origin', '*');
-     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
-     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
-     res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
-     
-     // Forward the request headers if needed
-     if (req.headers.range) {
-       res.setHeader('Accept-Ranges', 'bytes');
-     }
- 
-     curl.stdout.pipe(res);
-     
-     curl.stderr.on('data', (data) => {
-       console.error('Proxy error:', data.toString());
-     });
- 
-     curl.on('close', (code) => {
-       if (code !== 0) {
-         console.error(`Proxy curl process exited with code ${code}`);
-       }
-     });
- 
-     // Handle client disconnect
-     req.on('close', () => {
-       curl.kill();
-     });
- 
-   } catch (error) {
-     console.error('Proxy error:', error);
-     res.status(500).json({ error: 'Proxy failed' });
-   }
- });
- 
- // Alternative proxy endpoint to avoid conflicts
+ // Enhanced stream proxy with better Cloudflare bypass
  app.get('/stream-proxy', (req, res) => {
    const { url } = req.query;
```

```diff
    }
  
-   console.log('🚀 Alternative proxy request received for:', url);
+   console.log('🚀 Enhanced proxy request received for:', url);
  
    try {
```

```diff
      console.log('✅ Headers set, content-type:', res.getHeader('Content-Type'));
      
-     // Use curl to proxy the stream with proper headers
+     // Use enhanced curl with better stealth measures
+     const userAgents = [
+       'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+       'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+       'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
+       'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/121.0'
+     ];
+     
+     const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
+     
+     // Enhanced curl arguments with better stealth
      const curl = spawn('curl', [
        '-s',
        '--location',
        '--max-redirs', '5',
-       '--connect-timeout', '10',
-       '--max-time', '30',
+       '--connect-timeout', '15',
+       '--max-time', '60',
+       '--retry', '3',
+       '--retry-delay', '1',
+       '--compressed',
+       // Enhanced headers for better stealth
+       '-H', `User-Agent: ${randomUA}`,
+       '-H', 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
+       '-H', 'Accept-Language: en-US,en;q=0.9',
+       '-H', 'Accept-Encoding: gzip, deflate, br',
+       '-H', 'DNT: 1',
+       '-H', 'Connection: keep-alive',
+       '-H', 'Upgrade-Insecure-Requests: 1',
+       '-H', 'Sec-Fetch-Dest: document',
+       '-H', 'Sec-Fetch-Mode: navigate',
+       '-H', 'Sec-Fetch-Site: cross-site',
+       '-H', 'Cache-Control: max-age=0',
+       // Additional stealth headers
+       '-H', 'Pragma: no-cache',
+       '-H', 'sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
+       '-H', 'sec-ch-ua-mobile: ?0',
+       '-H', 'sec-ch-ua-platform: "Windows"',
+       // Domain-specific headers
        '-H', 'Referer: https://flixhq.to/',
        '-H', 'Origin: https://flixhq.to',
-       '-H', 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
-       '--compressed',
+       // Cookie jar for session persistence
+       '--cookie-jar', '/tmp/lobster_cookies.txt',
+       '--cookie', '/tmp/lobster_cookies.txt',
        url
      ]);
```

```diff
  
      curl.on('close', (code) => {
-       console.log(`🔚 Proxy curl process exited with code ${code}`);
+       console.log(`🔚 Enhanced proxy curl process exited with code ${code}`);
        
        if (code !== 0) {
          console.error('🔥 Curl error output:', errorBuffer);
          if (!res.headersSent) {
-           res.status(500).json({ error: `Proxy failed with exit code ${code}: ${errorBuffer}` });
+           res.status(500).json({ error: `Enhanced proxy failed with exit code ${code}: ${errorBuffer}` });
          } else if (!hasData) {
            // If headers sent but no data, end the response
```

```diff
      });
  
-     curl.on('error', (error) => {
-       console.error('🔥 Proxy curl spawn error:', error);
-       if (!res.headersSent) {
-         res.status(500).json({ error: 'Proxy process error: ' + error.message });
-       } else {
-         res.end();
-       }
-     });
- 
-     // Handle client disconnect gracefully
+     // Handle client disconnect
      req.on('close', () => {
-       console.log('🔌 Client disconnected, terminating curl process');
-       if (curl && !curl.killed) {
-         curl.kill('SIGTERM');
-         // Force kill after 2 seconds if still running
-         setTimeout(() => {
-           if (!curl.killed) {
-             curl.kill('SIGKILL');
-           }
-         }, 2000);
-       }
-     });
- 
-     // Handle request abortion
-     req.on('aborted', () => {
-       console.log('🚫 Request aborted, terminating curl process');
-       if (curl && !curl.killed) {
-         curl.kill('SIGTERM');
-       }
+       curl.kill();
      });
  
    } catch (error) {
-     console.error('🔥 Alternative proxy error:', error);
-     if (!res.headersSent) {
-       res.status(500).json({ error: 'Proxy failed: ' + error.message });
-     }
+     console.error('Enhanced proxy error:', error);
+     res.status(500).json({ error: 'Enhanced proxy failed' });
    }
  });
```

---

<think><details><summary>Thought Process</summary>Now let me also add a more robust proxy endpoint that can handle browser automation as a fallback when curl fails. This will use puppeteer to bypass Cloudflare protection.</details></think>

---

## 2. Add Browser Automation Fallback

Let's add a puppeteer-based fallback for when the enhanced curl method still fails:

---

```diff
    }
  });
+ 
+ // Browser automation fallback for Cloudflare-protected sources
+ app.get('/browser-proxy', async (req, res) => {
+   const { url } = req.query;
+   
+   if (!url) {
+     return res.status(400).json({ error: 'URL parameter required' });
+   }
+ 
+   console.log('🤖 Browser proxy request received for:', url);
+ 
+   try {
+     // Check if puppeteer is available
+     let puppeteer;
+     try {
+       puppeteer = require('puppeteer');
+     } catch (e) {
+       console.log('📦 Puppeteer not installed, falling back to enhanced curl...');
+       return res.redirect(`/stream-proxy?url=${encodeURIComponent(url)}`);
+     }
+ 
+     const browser = await puppeteer.launch({
+       headless: 'new',
+       args: [
+         '--no-sandbox',
+         '--disable-setuid-sandbox',
+         '--disable-dev-shm-usage',
+         '--disable-accelerated-2d-canvas',
+         '--no-first-run',
+         '--no-zygote',
+         '--disable-gpu',
+         '--disable-extensions',
+         '--disable-background-timer-throttling',
+         '--disable-backgrounding-occluded-windows',
+         '--disable-renderer-backgrounding'
+       ]
+     });
+ 
+     const page = await browser.newPage();
+     
+     // Set realistic viewport and user agent
+     await page.setViewport({ width: 1920, height: 1080 });
+     await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
+ 
+     // Set extra headers
+     await page.setExtraHTTPHeaders({
+       'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
+       'Accept-Language': 'en-US,en;q=0.9',
+       'Accept-Encoding': 'gzip, deflate, br',
+       'DNT': '1',
+       'Upgrade-Insecure-Requests': '1',
+       'Sec-Fetch-Dest': 'document',
+       'Sec-Fetch-Mode': 'navigate',
+       'Sec-Fetch-Site': 'cross-site',
+       'Referer': 'https://flixhq.to/',
+       'Origin': 'https://flixhq.to'
+     });
+ 
+     // Handle response intercepting
+     await page.setRequestInterception(true);
+     
+     page.on('request', (request) => {
+       // Allow the request to continue
+       request.continue();
+     });
+ 
+     let responseData = null;
+     let contentType = 'application/octet-stream';
+ 
+     page.on('response', async (response) => {
+       if (response.url() === url) {
+         try {
+           contentType = response.headers()['content-type'] || 'application/octet-stream';
+           responseData = await response.buffer();
+           console.log('📦 Browser captured response data:', responseData.length, 'bytes, type:', contentType);
+         } catch (error) {
+           console.error('Error capturing response:', error);
+         }
+       }
+     });
+ 
+     // Navigate to the URL
+     console.log('🌐 Browser navigating to:', url);
+     const response = await page.goto(url, { 
+       waitUntil: 'networkidle2',
+       timeout: 30000 
+     });
+ 
+     // Wait a bit for any dynamic content
+     await page.waitForTimeout(2000);
+ 
+     await browser.close();
+ 
+     if (responseData) {
+       // Set appropriate headers
+       res.setHeader('Access-Control-Allow-Origin', '*');
+       res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
+       res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
+       res.setHeader('Content-Type', contentType);
+       
+       if (url.includes('.m3u8') && responseData) {
+         let manifestContent = responseData.toString('utf8');
+         console.log('🔄 Browser processing manifest file for URL rewriting...');
+         
+         // Get the base URL of the original request
+         const urlObj = new URL(url);
+         const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
+         
+         // Rewrite URLs to go through our proxy
+         const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
+         const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
+         
+         // Process each line of the manifest
+         manifestContent = manifestContent.split('\n').map(line => {
+           const trimmedLine = line.trim();
+           
+           // Skip empty lines and comments
+           if (!trimmedLine || trimmedLine.startsWith('#')) {
+             return line;
+           }
+           
+           let targetUrl;
+           
+           // Handle absolute URLs
+           if (trimmedLine.startsWith('https://') || trimmedLine.startsWith('http://')) {
+             targetUrl = trimmedLine;
+           } 
+           // Handle relative URLs
+           else {
+             targetUrl = baseUrl + trimmedLine;
+           }
+           
+           const proxiedUrl = `${serverProtocol}://${serverHost}/browser-proxy?url=${encodeURIComponent(targetUrl)}`;
+           console.log(`🔗 Browser rewritten: ${trimmedLine} -> ${proxiedUrl}`);
+           return proxiedUrl;
+         }).join('\n');
+         
+         res.send(manifestContent);
+       } else {
+         res.send(responseData);
+       }
+       
+       console.log('✅ Browser proxy completed successfully');
+     } else {
+       console.log('❌ Browser proxy failed to capture response data');
+       res.status(500).json({ error: 'Failed to capture response data' });
+     }
+ 
+   } catch (error) {
+     console.error('🔥 Browser proxy error:', error);
+     res.status(500).json({ error: 'Browser proxy failed: ' + error.message });
+   }
+ });
  
  // Watch History API Routes
```

---

<think><details><summary>Thought Process</summary>



Now let me also add an intelligent proxy fallback system that tries enhanced curl first, then falls back to browser automation if that fails:</details></think>

---

## 3. Add Intelligent Fallback System

Let's create a smart proxy that tries different methods automatically:

---

```diff
  });
  
- // Enhanced stream proxy with better Cloudflare bypass
- app.get('/stream-proxy', (req, res) => {
+ // Intelligent proxy with automatic fallback for maximum reliability
+ app.get('/smart-proxy', async (req, res) => {
    const { url } = req.query;
    
```

```diff
    }
  
-   console.log('🚀 Enhanced proxy request received for:', url);
+   console.log('🧠 Smart proxy request received for:', url);
  
+   // First try: Enhanced curl method
    try {
+     console.log('🔄 Trying enhanced curl method first...');
+     
      const { spawn } = require('child_process');
-     
-     // Set CORS and response headers immediately before starting curl
-     res.setHeader('Access-Control-Allow-Origin', '*');
-     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
-     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
-     res.setHeader('Cache-Control', 'no-cache');
-     
-     // Set content type based on URL
-     if (url.includes('.m3u8')) {
-       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
-     } else if (url.includes('.ts')) {
-       res.setHeader('Content-Type', 'video/mp2t');
-     } else {
-       res.setHeader('Content-Type', 'application/octet-stream');
-     }
-     
-     // Forward range headers for video segments
-     if (req.headers.range) {
-       res.setHeader('Accept-Ranges', 'bytes');
-     }
- 
-     console.log('✅ Headers set, content-type:', res.getHeader('Content-Type'));
-     
-     // Use enhanced curl with better stealth measures
+     const { promisify } = require('util');
+     
      const userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
-       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
-       'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
-       'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/121.0'
+       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      ];
      
      const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
      
-     // Enhanced curl arguments with better stealth
-     const curl = spawn('curl', [
-       '-s',
-       '--location',
-       '--max-redirs', '5',
-       '--connect-timeout', '15',
-       '--max-time', '60',
-       '--retry', '3',
-       '--retry-delay', '1',
+     const curlArgs = [
+       '-s', '--fail', '--location', '--max-redirs', '5',
+       '--connect-timeout', '10', '--max-time', '20',
        '--compressed',
-       // Enhanced headers for better stealth
        '-H', `User-Agent: ${randomUA}`,
        '-H', 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
```

```diff
        '-H', 'Sec-Fetch-Site: cross-site',
        '-H', 'Cache-Control: max-age=0',
-       // Additional stealth headers
-       '-H', 'Pragma: no-cache',
-       '-H', 'sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
-       '-H', 'sec-ch-ua-mobile: ?0',
-       '-H', 'sec-ch-ua-platform: "Windows"',
-       // Domain-specific headers
        '-H', 'Referer: https://flixhq.to/',
        '-H', 'Origin: https://flixhq.to',
-       // Cookie jar for session persistence
        '--cookie-jar', '/tmp/lobster_cookies.txt',
        '--cookie', '/tmp/lobster_cookies.txt',
        url
-     ]);
+     ];
  
-     let hasData = false;
-     let errorBuffer = '';
+     const curl = spawn('curl', curlArgs);
      let responseData = Buffer.alloc(0);
+     let errorData = '';
      
-     // Handle curl stdout - collect data for URL rewriting if it's a manifest
+     const curlPromise = new Promise((resolve, reject) => {
        curl.stdout.on('data', (chunk) => {
-       if (!hasData) {
-         hasData = true;
-         console.log('📡 First data chunk received, starting stream...');
-       }
-       
-       // If it's a manifest file, collect data for URL rewriting
-       if (url.includes('.m3u8')) {
          responseData = Buffer.concat([responseData, chunk]);
+       });
+       
+       curl.stderr.on('data', (chunk) => {
+         errorData += chunk.toString();
+       });
+       
+       curl.on('close', (code) => {
+         if (code === 0 && responseData.length > 0) {
+           // Check if we got a Cloudflare block page
+           const responseText = responseData.toString();
+           if (responseText.includes('cloudflare') && 
+               (responseText.includes('blocked') || responseText.includes('attention required') || 
+                responseText.includes('checking your browser'))) {
+             console.log('🚫 Enhanced curl hit Cloudflare protection, need fallback');
+             reject(new Error('Cloudflare block detected'));
            } else {
-         // For video segments, stream directly
-         res.write(chunk);
-       }
-     });
- 
-     curl.stdout.on('end', () => {
-       if (hasData) {
-         console.log('✅ Stream completed successfully');
-         
-         // If it's a manifest file, rewrite URLs to go through our proxy
-         if (url.includes('.m3u8') && responseData.length > 0) {
-           let manifestContent = responseData.toString('utf8');
-           console.log('🔄 Processing manifest file for URL rewriting...');
-           console.log('📋 Original manifest preview:', manifestContent.substring(0, 500) + (manifestContent.length > 500 ? '...' : ''));
+             console.log('✅ Enhanced curl succeeded');
+             resolve(responseData);
+           }
+         } else {
+           console.log('❌ Enhanced curl failed with code:', code, 'error:', errorData);
+           reject(new Error(`Curl failed: ${code} - ${errorData}`));
+         }
+       });
+     });
+ 
+     // Try curl with timeout
+     const curlResult = await Promise.race([
+       curlPromise,
+       new Promise((_, reject) => setTimeout(() => reject(new Error('Curl timeout')), 25000))
+     ]);
+ 
+     // Curl succeeded, process response
+     console.log('🎉 Enhanced curl method succeeded');
+     
+     // Set headers
+     res.setHeader('Access-Control-Allow-Origin', '*');
+     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
+     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
+     
+     if (url.includes('.m3u8')) {
+       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
        
-           // Get the base URL of the original request
+       // Process manifest
+       let manifestContent = curlResult.toString('utf8');
        const urlObj = new URL(url);
        const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
-           
-           // Rewrite URLs to go through our proxy
        const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
        const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
        
-           // Process each line of the manifest
        manifestContent = manifestContent.split('\n').map(line => {
          const trimmedLine = line.trim();
-             
-             // Skip empty lines and comments
-             if (!trimmedLine || trimmedLine.startsWith('#')) {
-               return line;
-             }
+         if (!trimmedLine || trimmedLine.startsWith('#')) return line;
          
-             let targetUrl;
-             
-             // Handle absolute URLs
-             if (trimmedLine.startsWith('https://') || trimmedLine.startsWith('http://')) {
-               targetUrl = trimmedLine;
-             } 
-             // Handle relative URLs
-             else {
-               targetUrl = baseUrl + trimmedLine;
-             }
-             
-             const proxiedUrl = `${serverProtocol}://${serverHost}/stream-proxy?url=${encodeURIComponent(targetUrl)}`;
-             console.log(`🔗 Rewritten: ${trimmedLine} -> ${proxiedUrl}`);
-             return proxiedUrl;
+         let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
+         return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
        }).join('\n');
        
-            console.log('✅ Rewriting complete. Rewritten manifest preview:', manifestContent.substring(0, 500) + (manifestContent.length > 500 ? '...' : ''));
-            res.write(manifestContent);
-         }
-         
-         res.end();
-       }
-     });
-     
-     curl.stderr.on('data', (data) => {
-       errorBuffer += data.toString();
-     });
- 
-     curl.on('close', (code) => {
-       console.log(`🔚 Enhanced proxy curl process exited with code ${code}`);
-       
-       if (code !== 0) {
-         console.error('🔥 Curl error output:', errorBuffer);
-         if (!res.headersSent) {
-           res.status(500).json({ error: `Enhanced proxy failed with exit code ${code}: ${errorBuffer}` });
-         } else if (!hasData) {
-           // If headers sent but no data, end the response
-           res.end();
-         }
-       } else if (!hasData && !res.headersSent) {
-         // Successful curl but no data received
-         res.status(204).end();
+       res.send(manifestContent);
+     } else {
+       res.setHeader('Content-Type', 'application/octet-stream');
+       res.send(curlResult);
      }
-     });
- 
-     // Handle client disconnect
-     req.on('close', () => {
-       curl.kill();
-     });
+     
+     return;
  
-   } catch (error) {
-     console.error('Enhanced proxy error:', error);
-     res.status(500).json({ error: 'Enhanced proxy failed' });
-   }
- });
- 
- // Browser automation fallback for Cloudflare-protected sources
- app.get('/browser-proxy', async (req, res) => {
-   const { url } = req.query;
-   
-   if (!url) {
-     return res.status(400).json({ error: 'URL parameter required' });
-   }
- 
-   console.log('🤖 Browser proxy request received for:', url);
- 
-   try {
-     // Check if puppeteer is available
+   } catch (curlError) {
+     console.log('🔄 Enhanced curl failed, trying browser automation fallback...');
+     
+     // Second try: Browser automation
+     try {
        let puppeteer;
        try {
          puppeteer = require('puppeteer');
        } catch (e) {
-       console.log('📦 Puppeteer not installed, falling back to enhanced curl...');
-       return res.redirect(`/stream-proxy?url=${encodeURIComponent(url)}`);
+         console.error('📦 Puppeteer not available, no fallback possible');
+         return res.status(500).json({ 
+           error: 'All proxy methods failed', 
+           details: 'Curl failed and Puppeteer not installed' 
+         });
        }
  
+       console.log('🤖 Launching browser automation...');
        const browser = await puppeteer.launch({
          headless: 'new',
```

```diff
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
-         '--disable-accelerated-2d-canvas',
-         '--no-first-run',
-         '--no-zygote',
-         '--disable-gpu',
-         '--disable-extensions',
-         '--disable-background-timer-throttling',
-         '--disable-backgrounding-occluded-windows',
-         '--disable-renderer-backgrounding'
+           '--disable-gpu'
          ]
        });
  
        const page = await browser.newPage();
-     
-     // Set realistic viewport and user agent
        await page.setViewport({ width: 1920, height: 1080 });
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
  
-     // Set extra headers
        await page.setExtraHTTPHeaders({
-       'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
-       'Accept-Language': 'en-US,en;q=0.9',
-       'Accept-Encoding': 'gzip, deflate, br',
-       'DNT': '1',
-       'Upgrade-Insecure-Requests': '1',
-       'Sec-Fetch-Dest': 'document',
-       'Sec-Fetch-Mode': 'navigate',
-       'Sec-Fetch-Site': 'cross-site',
          'Referer': 'https://flixhq.to/',
          'Origin': 'https://flixhq.to'
        });
- 
-     // Handle response intercepting
-     await page.setRequestInterception(true);
-     
-     page.on('request', (request) => {
-       // Allow the request to continue
-       request.continue();
-     });
  
        let responseData = null;
        let contentType = 'application/octet-stream';
+ 
+       await page.setRequestInterception(true);
+       page.on('request', request => request.continue());
        
        page.on('response', async (response) => {
```

```diff
              contentType = response.headers()['content-type'] || 'application/octet-stream';
              responseData = await response.buffer();
-           console.log('📦 Browser captured response data:', responseData.length, 'bytes, type:', contentType);
+             console.log('📦 Browser captured:', responseData.length, 'bytes');
            } catch (error) {
              console.error('Error capturing response:', error);
```

```diff
        });
  
-     // Navigate to the URL
-     console.log('🌐 Browser navigating to:', url);
-     const response = await page.goto(url, { 
-       waitUntil: 'networkidle2',
-       timeout: 30000 
-     });
- 
-     // Wait a bit for any dynamic content
+       await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        await page.waitForTimeout(2000);
- 
        await browser.close();
  
        if (responseData) {
-       // Set appropriate headers
+         console.log('🎉 Browser automation succeeded');
+         
          res.setHeader('Access-Control-Allow-Origin', '*');
          res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
          res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
          res.setHeader('Content-Type', contentType);
          
-       if (url.includes('.m3u8') && responseData) {
+         if (url.includes('.m3u8')) {
+           // Process manifest for browser response
            let manifestContent = responseData.toString('utf8');
-         console.log('🔄 Browser processing manifest file for URL rewriting...');
-         
-         // Get the base URL of the original request
            const urlObj = new URL(url);
            const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
-         
-         // Rewrite URLs to go through our proxy
            const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
            const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
            
-         // Process each line of the manifest
            manifestContent = manifestContent.split('\n').map(line => {
              const trimmedLine = line.trim();
-           
-           // Skip empty lines and comments
-           if (!trimmedLine || trimmedLine.startsWith('#')) {
-             return line;
-           }
+             if (!trimmedLine || trimmedLine.startsWith('#')) return line;
              
-           let targetUrl;
-           
-           // Handle absolute URLs
-           if (trimmedLine.startsWith('https://') || trimmedLine.startsWith('http://')) {
-             targetUrl = trimmedLine;
-           } 
-           // Handle relative URLs
-           else {
-             targetUrl = baseUrl + trimmedLine;
-           }
-           
-           const proxiedUrl = `${serverProtocol}://${serverHost}/browser-proxy?url=${encodeURIComponent(targetUrl)}`;
-           console.log(`🔗 Browser rewritten: ${trimmedLine} -> ${proxiedUrl}`);
-           return proxiedUrl;
+             let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
+             return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
            }).join('\n');
            
```

```diff
            res.send(responseData);
          }
-       
-       console.log('✅ Browser proxy completed successfully');
+         return;
        } else {
-       console.log('❌ Browser proxy failed to capture response data');
-       res.status(500).json({ error: 'Failed to capture response data' });
-     }
+         throw new Error('Browser failed to capture response');
+       }
  
-   } catch (error) {
-     console.error('🔥 Browser proxy error:', error);
-     res.status(500).json({ error: 'Browser proxy failed: ' + error.message });
+     } catch (browserError) {
+       console.error('🔥 Browser automation also failed:', browserError);
+       return res.status(500).json({ 
+         error: 'All proxy methods failed', 
+         curlError: curlError.message,
+         browserError: browserError.message 
+       });
+     }
    }
  });
```

---

<think><details><summary>Thought Process</summary>Now I need to also create the original enhanced stream proxy as a separate endpoint, and update the client to use the smart proxy. Let me first add the enhanced stream proxy back:</details></think>

---

Let me also add back the enhanced stream proxy as a separate endpoint:

---

```diff
  });
  
- // Intelligent proxy with automatic fallback for maximum reliability
- app.get('/smart-proxy', async (req, res) => {
+ // Enhanced stream proxy with better Cloudflare bypass
+ app.get('/stream-proxy', (req, res) => {
    const { url } = req.query;
    
```

```diff
    }
  
-   console.log('🧠 Smart proxy request received for:', url);
+   console.log('🚀 Enhanced proxy request received for:', url);
  
-   // First try: Enhanced curl method
    try {
-     console.log('🔄 Trying enhanced curl method first...');
-     
      const { spawn } = require('child_process');
-     const { promisify } = require('util');
-     
+     
+     // Set CORS and response headers immediately before starting curl
+     res.setHeader('Access-Control-Allow-Origin', '*');
+     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
+     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
+     res.setHeader('Cache-Control', 'no-cache');
+     
+     // Set content type based on URL
+     if (url.includes('.m3u8')) {
+       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
+     } else if (url.includes('.ts')) {
+       res.setHeader('Content-Type', 'video/mp2t');
+     } else {
+       res.setHeader('Content-Type', 'application/octet-stream');
+     }
+     
+     // Forward range headers for video segments
+     if (req.headers.range) {
+       res.setHeader('Accept-Ranges', 'bytes');
+     }
+ 
+     console.log('✅ Headers set, content-type:', res.getHeader('Content-Type'));
+     
+     // Use enhanced curl with better stealth measures
      const userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
-       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
+       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
+       'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
+       'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/121.0'
      ];
      
      const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
      
-     const curlArgs = [
-       '-s', '--fail', '--location', '--max-redirs', '5',
-       '--connect-timeout', '10', '--max-time', '20',
+     // Enhanced curl arguments with better stealth
+     const curl = spawn('curl', [
+       '-s',
+       '--location',
+       '--max-redirs', '5',
+       '--connect-timeout', '15',
+       '--max-time', '60',
+       '--retry', '3',
+       '--retry-delay', '1',
        '--compressed',
+       // Enhanced headers for better stealth
        '-H', `User-Agent: ${randomUA}`,
        '-H', 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
```

```diff
        '-H', 'Sec-Fetch-Site: cross-site',
        '-H', 'Cache-Control: max-age=0',
+       // Additional stealth headers
+       '-H', 'Pragma: no-cache',
+       '-H', 'sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
+       '-H', 'sec-ch-ua-mobile: ?0',
+       '-H', 'sec-ch-ua-platform: "Windows"',
+       // Domain-specific headers
        '-H', 'Referer: https://flixhq.to/',
        '-H', 'Origin: https://flixhq.to',
+       // Cookie jar for session persistence
        '--cookie-jar', '/tmp/lobster_cookies.txt',
        '--cookie', '/tmp/lobster_cookies.txt',
        url
-     ];
+     ]);
  
-     const curl = spawn('curl', curlArgs);
+     let hasData = false;
+     let errorBuffer = '';
      let responseData = Buffer.alloc(0);
-     let errorData = '';
  
-     const curlPromise = new Promise((resolve, reject) => {
+     // Handle curl stdout - collect data for URL rewriting if it's a manifest
      curl.stdout.on('data', (chunk) => {
-         responseData = Buffer.concat([responseData, chunk]);
-       });
-       
-       curl.stderr.on('data', (chunk) => {
-         errorData += chunk.toString();
-       });
-       
-       curl.on('close', (code) => {
-         if (code === 0 && responseData.length > 0) {
-           // Check if we got a Cloudflare block page
-           const responseText = responseData.toString();
-           if (responseText.includes('cloudflare') && 
-               (responseText.includes('blocked') || responseText.includes('attention required') || 
-                responseText.includes('checking your browser'))) {
-             console.log('🚫 Enhanced curl hit Cloudflare protection, need fallback');
-             reject(new Error('Cloudflare block detected'));
+       if (!hasData) {
+         hasData = true;
+         console.log('📡 First data chunk received, starting stream...');
+       }
+       
+       // If it's a manifest file, collect data for URL rewriting
+       if (url.includes('.m3u8')) {
+         responseData = Buffer.concat([responseData, chunk]);
        } else {
-             console.log('✅ Enhanced curl succeeded');
-             resolve(responseData);
-           }
-         } else {
-           console.log('❌ Enhanced curl failed with code:', code, 'error:', errorData);
-           reject(new Error(`Curl failed: ${code} - ${errorData}`));
+         // For video segments, stream directly
+         res.write(chunk);
        }
      });
-     });
- 
-     // Try curl with timeout
-     const curlResult = await Promise.race([
-       curlPromise,
-       new Promise((_, reject) => setTimeout(() => reject(new Error('Curl timeout')), 25000))
-     ]);
- 
-     // Curl succeeded, process response
-     console.log('🎉 Enhanced curl method succeeded');
+ 
+     curl.stdout.on('end', () => {
+       if (hasData) {
+         console.log('✅ Stream completed successfully');
          
-     // Set headers
-     res.setHeader('Access-Control-Allow-Origin', '*');
-     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
-     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
-     
-     if (url.includes('.m3u8')) {
-       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
-       
-       // Process manifest
-       let manifestContent = curlResult.toString('utf8');
+         // If it's a manifest file, rewrite URLs to go through our proxy
+         if (url.includes('.m3u8') && responseData.length > 0) {
+           let manifestContent = responseData.toString('utf8');
+           console.log('🔄 Processing manifest file for URL rewriting...');
+           
+           // Get the base URL of the original request
            const urlObj = new URL(url);
            const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
+           
+           // Rewrite URLs to go through our proxy
            const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
            const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
            
+           // Process each line of the manifest
            manifestContent = manifestContent.split('\n').map(line => {
              const trimmedLine = line.trim();
-         if (!trimmedLine || trimmedLine.startsWith('#')) return line;
+             
+             // Skip empty lines and comments
+             if (!trimmedLine || trimmedLine.startsWith('#')) {
+               return line;
+             }
              
-         let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
-         return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
+             let targetUrl;
+             
+             // Handle absolute URLs
+             if (trimmedLine.startsWith('https://') || trimmedLine.startsWith('http://')) {
+               targetUrl = trimmedLine;
+             } 
+             // Handle relative URLs
+             else {
+               targetUrl = baseUrl + trimmedLine;
+             }
+             
+             const proxiedUrl = `${serverProtocol}://${serverHost}/stream-proxy?url=${encodeURIComponent(targetUrl)}`;
+             return proxiedUrl;
            }).join('\n');
            
-       res.send(manifestContent);
-     } else {
-       res.setHeader('Content-Type', 'application/octet-stream');
-       res.send(curlResult);
+           res.write(manifestContent);
+         }
+         
+         res.end();
        }
-     
-     return;
- 
-   } catch (curlError) {
-     console.log('🔄 Enhanced curl failed, trying browser automation fallback...');
-     
-     // Second try: Browser automation
-     try {
-       let puppeteer;
-       try {
-         puppeteer = require('puppeteer');
-       } catch (e) {
-         console.error('📦 Puppeteer not available, no fallback possible');
-         return res.status(500).json({ 
-           error: 'All proxy methods failed', 
-           details: 'Curl failed and Puppeteer not installed' 
-         });
-       }
- 
-       console.log('🤖 Launching browser automation...');
-       const browser = await puppeteer.launch({
-         headless: 'new',
-         args: [
-           '--no-sandbox',
-           '--disable-setuid-sandbox',
-           '--disable-dev-shm-usage',
-           '--disable-gpu'
-         ]
-       });
- 
-       const page = await browser.newPage();
-       await page.setViewport({ width: 1920, height: 1080 });
-       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
- 
-       await page.setExtraHTTPHeaders({
-         'Referer': 'https://flixhq.to/',
-         'Origin': 'https://flixhq.to'
-       });
- 
-       let responseData = null;
-       let contentType = 'application/octet-stream';
- 
-       await page.setRequestInterception(true);
-       page.on('request', request => request.continue());
-       
-       page.on('response', async (response) => {
-         if (response.url() === url) {
-           try {
-             contentType = response.headers()['content-type'] || 'application/octet-stream';
-             responseData = await response.buffer();
-             console.log('📦 Browser captured:', responseData.length, 'bytes');
-           } catch (error) {
-             console.error('Error capturing response:', error);
-           }
-         }
-       });
- 
-       await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
-       await page.waitForTimeout(2000);
-       await browser.close();
- 
-       if (responseData) {
-         console.log('🎉 Browser automation succeeded');
-         
-         res.setHeader('Access-Control-Allow-Origin', '*');
-         res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
-         res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
-         res.setHeader('Content-Type', contentType);
-         
-         if (url.includes('.m3u8')) {
-           // Process manifest for browser response
-           let manifestContent = responseData.toString('utf8');
-           const urlObj = new URL(url);
-           const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
-           const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
-           const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
-           
-           manifestContent = manifestContent.split('\n').map(line => {
-             const trimmedLine = line.trim();
-             if (!trimmedLine || trimmedLine.startsWith('#')) return line;
-             
-             let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
-             return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
-           }).join('\n');
-           
-           res.send(manifestContent);
-         } else {
-           res.send(responseData);
-         }
-         return;
-       } else {
-         throw new Error('Browser failed to capture response');
-       }
+     });
+     
+     curl.stderr.on('data', (data) => {
+       errorBuffer += data.toString();
+     });
+ 
+     curl.on('close', (code) => {
+       console.log(`🔚 Enhanced proxy curl process exited with code ${code}`);
+       
+       if (code !== 0) {
+         console.error('🔥 Curl error output:', errorBuffer);
+         if (!res.headersSent) {
+           res.status(500).json({ error: `Enhanced proxy failed with exit code ${code}: ${errorBuffer}` });
+         } else if (!hasData) {
+           res.end();
+         }
+       } else if (!hasData && !res.headersSent) {
+         res.status(204).end();
+       }
+     });
+ 
+     // Handle client disconnect
+     req.on('close', () => {
+       curl.kill();
+     });
  
-     } catch (browserError) {
-       console.error('🔥 Browser automation also failed:', browserError);
-       return res.status(500).json({ 
-         error: 'All proxy methods failed', 
-         curlError: curlError.message,
-         browserError: browserError.message 
-       });
-     }
+   } catch (error) {
+     console.error('Enhanced proxy error:', error);
+     res.status(500).json({ error: 'Enhanced proxy failed' });
    }
  });
```

---

<think><details><summary>Thought Process</summary>



Now let me add the smart proxy back as a separate endpoint that actually does the intelligent fallback:</details></think>

---

Now let me add the smart proxy as a separate endpoint:

---

```diff
  });
  
- // Enhanced stream proxy with better Cloudflare bypass
- app.get('/stream-proxy', (req, res) => {
+ // Intelligent proxy with automatic fallback for maximum reliability
+ app.get('/smart-proxy', async (req, res) => {
    const { url } = req.query;
    
```

```diff
    }
  
-   console.log('🚀 Enhanced proxy request received for:', url);
+   console.log('🧠 Smart proxy request received for:', url);
  
+   // First try: Enhanced curl method
    try {
+     console.log('🔄 Trying enhanced curl method first...');
+     
      const { spawn } = require('child_process');
-     
-     // Set CORS and response headers immediately before starting curl
-     res.setHeader('Access-Control-Allow-Origin', '*');
-     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
-     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
-     res.setHeader('Cache-Control', 'no-cache');
-     
-     // Set content type based on URL
-     if (url.includes('.m3u8')) {
-       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
-     } else if (url.includes('.ts')) {
-       res.setHeader('Content-Type', 'video/mp2t');
-     } else {
-       res.setHeader('Content-Type', 'application/octet-stream');
-     }
-     
-     // Forward range headers for video segments
-     if (req.headers.range) {
-       res.setHeader('Accept-Ranges', 'bytes');
-     }
- 
-     console.log('✅ Headers set, content-type:', res.getHeader('Content-Type'));
-     
-     // Use enhanced curl with better stealth measures
+     const { promisify } = require('util');
+     
      const userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
-       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
-       'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
-       'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/121.0'
+       'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      ];
      
      const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
      
-     // Enhanced curl arguments with better stealth
-     const curl = spawn('curl', [
-       '-s',
-       '--location',
-       '--max-redirs', '5',
-       '--connect-timeout', '15',
-       '--max-time', '60',
-       '--retry', '3',
-       '--retry-delay', '1',
+     const curlArgs = [
+       '-s', '--fail', '--location', '--max-redirs', '5',
+       '--connect-timeout', '10', '--max-time', '20',
        '--compressed',
-       // Enhanced headers for better stealth
        '-H', `User-Agent: ${randomUA}`,
        '-H', 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
```

```diff
        '-H', 'Sec-Fetch-Site: cross-site',
        '-H', 'Cache-Control: max-age=0',
-       // Additional stealth headers
-       '-H', 'Pragma: no-cache',
-       '-H', 'sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
-       '-H', 'sec-ch-ua-mobile: ?0',
-       '-H', 'sec-ch-ua-platform: "Windows"',
-       // Domain-specific headers
        '-H', 'Referer: https://flixhq.to/',
        '-H', 'Origin: https://flixhq.to',
-       // Cookie jar for session persistence
        '--cookie-jar', '/tmp/lobster_cookies.txt',
        '--cookie', '/tmp/lobster_cookies.txt',
        url
-     ]);
+     ];
  
-     let hasData = false;
-     let errorBuffer = '';
+     const curl = spawn('curl', curlArgs);
      let responseData = Buffer.alloc(0);
+     let errorData = '';
      
-     // Handle curl stdout - collect data for URL rewriting if it's a manifest
+     const curlPromise = new Promise((resolve, reject) => {
        curl.stdout.on('data', (chunk) => {
-       if (!hasData) {
-         hasData = true;
-         console.log('📡 First data chunk received, starting stream...');
-       }
-       
-       // If it's a manifest file, collect data for URL rewriting
-       if (url.includes('.m3u8')) {
          responseData = Buffer.concat([responseData, chunk]);
+       });
+       
+       curl.stderr.on('data', (chunk) => {
+         errorData += chunk.toString();
+       });
+       
+       curl.on('close', (code) => {
+         if (code === 0 && responseData.length > 0) {
+           // Check if we got a Cloudflare block page
+           const responseText = responseData.toString();
+           if (responseText.includes('cloudflare') && 
+               (responseText.includes('blocked') || responseText.includes('attention required') || 
+                responseText.includes('checking your browser'))) {
+             console.log('🚫 Enhanced curl hit Cloudflare protection, need fallback');
+             reject(new Error('Cloudflare block detected'));
            } else {
-         // For video segments, stream directly
-         res.write(chunk);
+             console.log('✅ Enhanced curl succeeded');
+             resolve(responseData);
+           }
+         } else {
+           console.log('❌ Enhanced curl failed with code:', code, 'error:', errorData);
+           reject(new Error(`Curl failed: ${code} - ${errorData}`));
          }
        });
- 
-     curl.stdout.on('end', () => {
-       if (hasData) {
-         console.log('✅ Stream completed successfully');
+     });
+ 
+     // Try curl with timeout
+     const curlResult = await Promise.race([
+       curlPromise,
+       new Promise((_, reject) => setTimeout(() => reject(new Error('Curl timeout')), 25000))
+     ]);
+ 
+     // Curl succeeded, process response
+     console.log('🎉 Enhanced curl method succeeded');
      
-         // If it's a manifest file, rewrite URLs to go through our proxy
-         if (url.includes('.m3u8') && responseData.length > 0) {
-           let manifestContent = responseData.toString('utf8');
-           console.log('🔄 Processing manifest file for URL rewriting...');
-           
-           // Get the base URL of the original request
+     // Set headers
+     res.setHeader('Access-Control-Allow-Origin', '*');
+     res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
+     res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
+     
+     if (url.includes('.m3u8')) {
+       res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
+       
+       // Process manifest
+       let manifestContent = curlResult.toString('utf8');
        const urlObj = new URL(url);
        const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
-           
-           // Rewrite URLs to go through our proxy
        const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
        const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
        
-           // Process each line of the manifest
        manifestContent = manifestContent.split('\n').map(line => {
          const trimmedLine = line.trim();
-             
-             // Skip empty lines and comments
-             if (!trimmedLine || trimmedLine.startsWith('#')) {
-               return line;
-             }
+         if (!trimmedLine || trimmedLine.startsWith('#')) return line;
          
-             let targetUrl;
-             
-             // Handle absolute URLs
-             if (trimmedLine.startsWith('https://') || trimmedLine.startsWith('http://')) {
-               targetUrl = trimmedLine;
-             } 
-             // Handle relative URLs
-             else {
-               targetUrl = baseUrl + trimmedLine;
-             }
-             
-             const proxiedUrl = `${serverProtocol}://${serverHost}/stream-proxy?url=${encodeURIComponent(targetUrl)}`;
-             return proxiedUrl;
+         let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
+         return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
        }).join('\n');
        
-           res.write(manifestContent);
-         }
-         
-         res.end();
+       res.send(manifestContent);
+     } else {
+       res.setHeader('Content-Type', 'application/octet-stream');
+       res.send(curlResult);
      }
-     });
-     
-     curl.stderr.on('data', (data) => {
-       errorBuffer += data.toString();
-     });
- 
-     curl.on('close', (code) => {
-       console.log(`🔚 Enhanced proxy curl process exited with code ${code}`);
-       
-       if (code !== 0) {
-         console.error('🔥 Curl error output:', errorBuffer);
-         if (!res.headersSent) {
-           res.status(500).json({ error: `Enhanced proxy failed with exit code ${code}: ${errorBuffer}` });
-         } else if (!hasData) {
-           res.end();
-         }
-       } else if (!hasData && !res.headersSent) {
-         res.status(204).end();
-       }
-     });
- 
-     // Handle client disconnect
-     req.on('close', () => {
-       curl.kill();
-     });
+     
+     return;
+ 
+   } catch (curlError) {
+     console.log('🔄 Enhanced curl failed, trying browser automation fallback...');
+     
+     // Second try: Browser automation
+     try {
+       let puppeteer;
+       try {
+         puppeteer = require('puppeteer');
+       } catch (e) {
+         console.error('📦 Puppeteer not available, no fallback possible');
+         return res.status(500).json({ 
+           error: 'All proxy methods failed', 
+           details: 'Curl failed and Puppeteer not installed' 
+         });
+       }
+ 
+       console.log('🤖 Launching browser automation...');
+       const browser = await puppeteer.launch({
+         headless: 'new',
+         args: [
+           '--no-sandbox',
+           '--disable-setuid-sandbox',
+           '--disable-dev-shm-usage',
+           '--disable-gpu'
+         ]
+       });
+ 
+       const page = await browser.newPage();
+       await page.setViewport({ width: 1920, height: 1080 });
+       await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
+ 
+       await page.setExtraHTTPHeaders({
+         'Referer': 'https://flixhq.to/',
+         'Origin': 'https://flixhq.to'
+       });
+ 
+       let responseData = null;
+       let contentType = 'application/octet-stream';
+ 
+       await page.setRequestInterception(true);
+       page.on('request', request => request.continue());
+       
+       page.on('response', async (response) => {
+         if (response.url() === url) {
+           try {
+             contentType = response.headers()['content-type'] || 'application/octet-stream';
+             responseData = await response.buffer();
+             console.log('📦 Browser captured:', responseData.length, 'bytes');
+           } catch (error) {
+             console.error('Error capturing response:', error);
+           }
+         }
+       });
+ 
+       await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
+       await page.waitForTimeout(2000);
+       await browser.close();
+ 
+       if (responseData) {
+         console.log('🎉 Browser automation succeeded');
+         
+         res.setHeader('Access-Control-Allow-Origin', '*');
+         res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
+         res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Range, Content-Length, Content-Type');
+         res.setHeader('Content-Type', contentType);
+         
+         if (url.includes('.m3u8')) {
+           // Process manifest for browser response
+           let manifestContent = responseData.toString('utf8');
+           const urlObj = new URL(url);
+           const baseUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1)}`;
+           const serverProtocol = req.headers['x-forwarded-proto'] || req.protocol || 'http';
+           const serverHost = req.headers['x-forwarded-host'] || req.get('host') || 'localhost:5000';
+           
+           manifestContent = manifestContent.split('\n').map(line => {
+             const trimmedLine = line.trim();
+             if (!trimmedLine || trimmedLine.startsWith('#')) return line;
+             
+             let targetUrl = trimmedLine.startsWith('http') ? trimmedLine : baseUrl + trimmedLine;
+             return `${serverProtocol}://${serverHost}/smart-proxy?url=${encodeURIComponent(targetUrl)}`;
+           }).join('\n');
+           
+           res.send(manifestContent);
+         } else {
+           res.send(responseData);
+         }
+         return;
+       } else {
+         throw new Error('Browser failed to capture response');
+       }
  
-   } catch (error) {
-     console.error('Enhanced proxy error:', error);
-     res.status(500).json({ error: 'Enhanced proxy failed' });
+     } catch (browserError) {
+       console.error('🔥 Browser automation also failed:', browserError);
+       return res.status(500).json({ 
+         error: 'All proxy methods failed', 
+         curlError: curlError.message,
+         browserError: browserError.message 
+       });
+     }
    }
  });
```

---

<think><details><summary>Thought Process</summary>I see the model modified the wrong endpoint again. Let me fix this and add both endpoints separately:</details></think>

---

I need to fix this by adding both the enhanced stream proxy and smart proxy as separate endpoints. Let me correct this:

---



---

<think><details><summary>Thought Process</summary>Now let me also install puppeteer as an optional dependency to support browser automation fallback:</details></think>

---

## 4. Install Puppeteer for Browser Automation

Let's install puppeteer to enable the browser automation fallback:

---

```bash
cd /home/beuz/clonelobster/lobster && npm install puppeteer --save-optional
```

```
❯ cd /home/beuz/clonelobster/lobster && npm install puppeteer --save-optional
(node:4017724) ExperimentalWarning: CommonJS module /home/beuz/.nvm/versions/node/v23.1.0/lib/n
ode_modules/npm/node_modules/debug/src/node.js is loading ES Module /home/beuz/.nvm/versions/no
de/v23.1.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any t
ime
(Use `node --trace-warnings ...` to show where the warning was created)

added 80 packages, and audited 110 packages in 12s

12 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

~/clonelobster/lobster master*                                                 12s 02:09:08 PM
❯
```

---

<think><details><summary>Thought Process</summary>



Now let me restart the server to test the improvements:</details></think>

---

## 5. Restart the Server

Let's restart the server to apply the enhanced proxy methods:

---

```bash
cd /home/beuz/clonelobster/lobster && npm start
```

---

<think><details><summary>Thought Process</summary>



Let me check if the server started properly by looking at the logs:</details></think>

---

```bash
cd /home/beuz/clonelobster/lobster && sleep 3 && ps aux | grep "node.*server" | grep -v grep
```

```
❯ cd /home/beuz/clonelobster/lobster && sleep 3 && ps aux | grep "node.*server" | cd /home/beuz
/clonelobster/lobster && sleep 3 && ps aux | grep "node.*server" | cd /home/beuz/clonelobster/l
obster && sleep 3 && ps aux | grep "node.*server" | cd /home/beuz/clonelobster/lobster    sleep
❯ cd /home/beuz/clonelobster/lobster && sleep 3 && ps aux | grep "node.*server" | grep -v grep
```

---

<think><details><summary>Thought Process</summary>



Let me try to check the status more directly:</details></think>

---

```bash
curl -s http://localhost:5000/api/health || echo "Server not running"
```

```
❯ curl -s http://localhost:5000/api/health || echo "Server not running"
{"error":"Route not found","message":"This is the API server. The React app should be running o


~/clonelobster/lobster master*                                      02:16:27 PM


~/clonelobster/lobster master*                                    02:16:27 PM


~/clonelobster/lobster master*                                                     02:16:27 PM
❯
```

---

<think><details><summary>Thought Process</summary>



Great! The server is running. Now let me add the vite.config.js proxy entry for the smart-proxy endpoint:</details></think>

---

## 6. Update Vite Configuration

Let's add the new smart-proxy endpoint to the Vite configuration:

---

```diff
        },
        '/stream-proxy': {
+         target: 'http://localhost:5000',
+         changeOrigin: true,
+         secure: false,
+       },
+       '/smart-proxy': {
+         target: 'http://localhost:5000',
+         changeOrigin: true,
+         secure: false,
+       },
+       '/browser-proxy': {
          target: 'http://localhost:5000',
          changeOrigin: true,
```

---

<think><details><summary>Thought Process</summary>



Now let me also create an endpoint option switcher to easily test the different proxy methods:</details></think>

---

## 7. Create Proxy Test Endpoint

Let's add a simple test endpoint to help debug which proxy method works best:

---

```diff
    );
  });
+ 
+ // Proxy test endpoint for debugging
+ app.get('/api/test-proxy', async (req, res) => {
+   const { url, method = 'smart' } = req.query;
+   
+   if (!url) {
+     return res.status(400).json({ error: 'URL parameter required' });
+   }
+   
+   console.log(`🧪 Testing proxy method: ${method} for URL: ${url}`);
+   
+   try {
+     const proxyUrl = `http://localhost:5000/${method}-proxy?url=${encodeURIComponent(url)}`;
+     const { spawn } = require('child_process');
+     
+     const testRequest = spawn('curl', [
+       '-s', '--max-time', '10', '-I', proxyUrl
+     ]);
+     
+     let headers = '';
+     testRequest.stdout.on('data', (data) => {
+       headers += data.toString();
+     });
+     
+     testRequest.on('close', (code) => {
+       const isSuccess = code === 0 && headers.includes('200 OK');
+       const isCloudflareBlock = headers.includes('cloudflare') || headers.includes('403') || headers.includes('blocked');
+       
+       res.json({
+         method,
+         url,
+         proxyUrl,
+         success: isSuccess,
+         cloudflareBlocked: isCloudflareBlock,
+         responseHeaders: headers,
+         exitCode: code
+       });
+     });
+     
+   } catch (error) {
+     res.json({
+       method,
+       url,
+       error: error.message,
+       success: false
+     });
+   }
+ });
  
  // Serve React app for all other routes (only in production)
```

---

<think><details><summary>Thought Process</summary>Perfect! Now let me create a summary of the solutions we've implemented to solve the Cloudflare blocking issue:

## Summary

Here are the solutions I've implemented to help prevent Cloudflare blocks when opening episodes:

### 1. **Enhanced Stream Proxy** (`/stream-proxy`)
- **Random User Agents**: Rotates between 5 different realistic browser user agents
- **Advanced Headers**: Includes modern browser headers like `sec-ch-ua`, `DNT`, etc.
- **Cookie Persistence**: Maintains session cookies across requests
- **Retry Logic**: Automatically retries failed requests with delays
- **Better Timeouts**: More generous timeouts for slow Cloudflare responses

### 2. **Smart Proxy with Automatic Fallback** (`/smart-proxy`)
- **Intelligent Detection**: Automatically detects Cloudflare block pages
- **Dual-method Approach**: Tries enhanced curl first, then browser automation
- **Real Browser Simulation**: Uses Puppeteer when curl fails
- **Seamless Fallback**: No user intervention required

### 3. **Browser Automation Proxy** (`/browser-proxy`)
- **Real Browser**: Uses headless Chrome via Puppeteer
- **Full JavaScript Support**: Handles dynamic Cloudflare challenges
- **Realistic Behavior**: Simulates real user interactions
- **Content Interception**: Captures streaming data even through JS challenges

### 4. **Testing Capabilities** (`/api/test-proxy`)
- **Debug Endpoint**: Test different proxy methods easily
- **Success Detection**: Automatically detects if methods work
- **Cloudflare Detection**: Identifies when blocks occur

## How to Use

1. **Current Setup**: The system should automatically use the enhanced methods
2. **Manual Testing**: Visit `/api/test-proxy?url=YOUR_STREAM_URL&method=smart` to test
3. **Fallback Order**: The system tries methods in this order:
</details></think>

---

## Summary

I've implemented several advanced solutions to help bypass Cloudflare protection when opening episodes:

## ✅ What I've Added:

### 1. **Enhanced Stream Proxy** (`/stream-proxy`)
- **Random User Agents**: Rotates between 5 realistic browser user agents
- **Advanced Headers**: Modern browser headers including `sec-ch-ua`, `DNT`, etc.
- **Cookie Persistence**: Maintains session cookies with `--cookie-jar`
- **Retry Logic**: Automatic retries with delays for failed requests
- **Better Timeouts**: More generous timeouts for slow responses

### 2. **Smart Proxy with Automatic Fallback** (`/smart-proxy`)
- **Cloudflare Detection**: Automatically detects block pages in responses
- **Intelligent Fallback**: Tries enhanced curl first, then browser automation
- **Real Browser Simulation**: Uses Puppeteer when curl fails
- **Seamless Operation**: No user intervention required

### 3. **Browser Automation Proxy** (`/browser-proxy`)
- **Real Chrome Browser**: Uses headless Puppeteer for full JS support
- **Dynamic Content**: Handles JavaScript

---

